{% extends 'portfolio/base.html' %}

{% load static %}

{% block content %}
<h1>Project21: Database Design</h1>

<div class="step">
    <h2>Introduction</h2>
    <p>This project demonstrates how to design and build a relational database.</p>
    <p>A good db design contributes to integrity of data, minimal redundancy, high performance and user satisfaction.</p>
    <p>To achieve an optimal database design, it is important to adhere to best practices to avoid costly problems later.</p>
    <p>In the steps below, I start with important concepts that will be considered in the design.</p>
    <p>A number of examples are provided to illustrate the concepts.</p>
    <p>The outcome will be a HR database design created in the ERD tool of pgAdmin.</p>    
    <p>Finally, I show how to implement the design in PostgreSQL using the SQL generated by the ERD tool.</p>
    <br>
    <br>
    <h2>Design Considerations</h2>
    <p>Before starting the design, it is important to understand the business requirements and data needs of the application.<br>
        This involves collaborating closely with business stakeholders.<br>
        This will help to identify the entities, attributes and relationships that need to be represented in the database.</p>
    <p>To arrive at a list of entities and the relationships between them, normalization is used.<br>
        Normalization is a process of organizing the data in the database to minimize redundancy and dependency by dividing large tables into smaller ones and defining relationships between them.</p>
        For example, consider a customer placing multiple orders. Instead of storing customer information (such as name and address) with each order, you can normalize the data by creating separate tables for Customers and Orders.
        This approach minimizes data duplication and ensures updates to customer information across all of their associated orders.</p>
    <p>Normalization accelerates transactions by facilitating updates, additions, and deletes to be performed only once.</br>
        Data duplication leads to inconsistencies because multiple copies of the same data increase the risk of conflicts and errors when the information is updated, modified, or deleted.</br>
        Normalisation organises data logically. This improves data integrity, reduces redundancy and enhances data consistency.</p>
    <p>There are multiple methods of normalisation including first (1NF), second (2NF), and third (3NF) and higher normal forms.</br>
        The most used methods of normalisation are first (1NF), second (2NF), and third (3NF) normal forms.</br>
        Focus on normalising each table. This will require creating more tables.</p>
    <p>First Normal Form (1NF): Each table has a primary key, each row must be unique, each cell must contain only a single value.</br>
        In a Books table for example, if a book comes in both paperback and hardback format, there should not be a row for the book with both paperback and hardback in the format column.</br>
        Instead split it into 2 rows, one for paperback and one for hardback. The table is now in 1NF.</p>
        Second Normal Form (2NF): the table must already be in 1NF, then separate groups of values that apply to multiple rows into separate tables.</br>
        The idea is to have only one row in a table for a particular item. Then link the 2 tables with a primary key and foreign key.</br>
        In the Books example, there should be only one row for the book that comes in both paperback and hardback.</br>
        So remove one of the rows and remove the Format column from the Books table and create a new table called Format with attributes Book_id and Format.</br>
        There should be 2 rows in this table for the book, one for paperback and one for hardback.</br>
        The tables should be linked by primary/foreign key on the Book_id column.</br>
        The tables are now in 2NF.</p>
        Third Normal Form (3NF): the table must already be in 1NF and 2NF.</br>
        Eliminate cols that do not depend on the primary key.</br>
        A transitive dependency occurs when a non-key attribute depends on another non-key attribute.</br>
        For each transitive dependency, create a new table to eliminate the dependency.</br>
        For instance, if a book's shipping location depends on the publisher, it should be moved to a separate publisher table.</br>
        This helps to ensure that all non-key attributes are only dependent on the primary key.</br>
        Use foreign keys to maintain relationships between the new tables and the original table.</br>
        For example, if a Books table has columns for Publisher and Ships From, then it is not in 3NF because Ships From depends on the Publisher, not the Book_id.</br>
        So replace the 2 columns in the Books table with a Publisher_id column, create a new table called Publisher that has primary key of Publisher_id and other columns for Publisher_Name and Ships_From.</br>
        The Publisher_id column in the Books table is a foreign key linked to the Publisher_id primary key in the Publisher table.</br>
        Another Example: 
        In an ecommerce site, consider a table in 2NF with the following columns:
        OrderID (Primary Key), ProductID, CustomerID, CustomerName, CustomerAddress</br>
        To apply 3NF, first identify Transitive Dependencies: CustomerName and CustomerAddress depend on CustomerID, not directly on OrderID.</br>
        Then create a new tables for Customers with columns: CustomerID, CustomerName, CustomerAddress</br>
        Alter the Orders table to have columns: OrderID, ProductID, CustomerID</br>
        The Orders table is now in 3NF.</p>
        3NF is as far as most relational dbs go. There are higher normal forms like Boyce-Codd Normal Form (BCNF) which may be needed for specific scenarios.</br>
        3NF mainly applies to OLTP databases which are designed for transaction processing and must handle a large number of transactions quickly and efficiently.</br>
        They are typically used for applications that require real-time data access and updates, such as online banking, e-commerce, and customer relationship management (CRM) systems.</br>
        OLTP databases are designed to support a high volume of concurrent users and transactions.</br>
        Because OLTP databases involve frequent reading and writing of data they benefit from being normalised to 3NF.</br>
        OLAP databases, on the other hand, are designed for analytical processing such as data analysis, such as business intelligence, data warehousing, modelling and reporting.</br>
        For these applications, read performance is more important than write performance.</br>
        Because they prioritise read performance, having fewer tables to process, hence a lower normal form, may be desirable.</br>
        So when data is loaded from OLTP databases to OLAP databases for analysis, it is often denormalised to improve read performance.</br>
</div>

<div class="step">
    <br>
    <br>
    <h2>Create the HR Database</h2>
    <p>For the purposes of this demonstration, a partial HR database will be created.</p>
    <p>It consists of 4 entities: employees, jobs, departments and locations.</p>
    <p>Relationships are created between the tables as appropriate.</p>
    <p>The database is created first in the pgAdmin ERD tool, then the SQL is generated and run to create the database objects.</p>
    <p>This screenshot shows the HR databse being created in the ERD tool.</p>
    <button class="screenshot-btn" onclick="toggleScreenshot('createhrdbinpgadmin', this)">View Screenshot</button>
    <img src="{% static 'portfolio/project21/createhrdbinpgadmin.png' %}" id="createhrdbinpgadmin" class="screenshot" alt="createhrdbinpgadmin">
    <button class="hide-btn" onclick="hideScreenshot('createhrdbinpgadmin')" style="display: none;" id="hide-createhrdbinpgadmin">Hide Screenshot</button>
</div>

<div class="step">
    <br>
    <br>
    <h2>Create the ERD for the HR database.</h2>
    <p>This screenshot shows the ERD being created.</p>
    <p>Right-click on the database and select "ERD for Database".</p>
    <button class="screenshot-btn" onclick="toggleScreenshot('create-hr-erd', this)">View Screenshot</button>
    <img src="{% static 'portfolio/project21/create-hr-erd.png' %}" id="create-hr-erd" class="screenshot" alt="create-hr-erd">
    <button class="hide-btn" onclick="hideScreenshot('create-hr-erd')" style="display: none;" id="hide-create-hr-erd">Hide Screenshot</button>
</div>

<div class="step">
    <br>
    <br>
    <h2>Create Tables in the ERD.</h2>
    <p>To create tables, Click the New Table button in the ERD tool as shown here.</p>
    <p>Then enter the table name and add the columns.</p>
    <p>Click the Save button to save the table.</p>
    <button class="screenshot-btn" onclick="toggleScreenshot('createtable', this)">View Screenshot</button>
    <img src="{% static 'portfolio/project21/createtable.png' %}" id="createtable" class="screenshot" alt="createtable">
    <button class="hide-btn" onclick="hideScreenshot('createtable')" style="display: none;" id="hide-createtable">Hide Screenshot</button>
</div>


<div class="step">
    <br>
    <br>
    <h2>All Tables Created</h2>
    <p>This screenshot shows the 4 tables employees, jobs, departments and locations with their associated columns in the diagram.</p>
    <button class="screenshot-btn" onclick="toggleScreenshot('tablescreated', this)">View Screenshot</button>
    <img src="{% static 'portfolio/project21/tablescreated.png' %}" id="tablescreated" class="screenshot" alt="tablescreated">
    <button class="hide-btn" onclick="hideScreenshot('tablescreated')" style="display: none;" id="hide-tablescreated">Hide Screenshot</button>
</div>

<div class="step">
    <br>
    <br>
    <h2>Create Relationships between Tables.</h2>
    <p>Once the tables are created, the relationships need to be established between them.</p>
    <p>Relationships are created by adding foreign keys to the tables that link them to other tables.</p>
    <p>You need to know in advance if the relationship is one-to-one, one-to-many or many-to-many.</p>
    <p>In this example, the departments table has a one-to-many relationship to the employees table.</p>
    <p>In other words, each department can have multiple employees, but each employee belongs to only one department.</p>
    <p>To create the relationship, click on the employees table then click on the 1M icon in the ERD tool.</p>
    <p>Select the department_id as the foreign key in the employees table.</p>
    <p>Then select the departments table as the Referenced table.</p>
    <p>Then select the department_id as the Referenced column.</p>
    <p>Click the OK button to save the relationship.</p>
    <p>Repeat this process for the other relationships.</p>
    <button class="screenshot-btn" onclick="toggleScreenshot('onetomany', this)">View Screenshot</button>
    <img src="{% static 'portfolio/project21/onetomany.png' %}" id="onetomany" class="screenshot" alt="onetomany">
    <button class="hide-btn" onclick="hideScreenshot('onetomany')" style="display: none;" id="hide-onetomany">Hide Screenshot</button>
</div>

<div class="step">
    <br>
    <br>
    <h2>Relationships Created</h2>
    <p>This screenshot shows the 4 tables with the relationships created.</p>
    <p>The one-to-many relationship is represented using crows feet notation.</p>
    <p>This is the > sign at the end of the lines linking the tables.</p>
    <p>For example the employees has the > on the department_id column.</p>
    <p>The other end of the line on the departments table is a straight line with no >.</p>
    <p>This indicates that the employees table has a one-to-many relationship with the departments table.</p>
    <p>In other words, each department can have multiple employees, but each employee belongs to only one department.</p>
    <p></p>
    <button class="screenshot-btn" onclick="toggleScreenshot('tableswithrelations', this)">View Screenshot</button>
    <img src="{% static 'portfolio/project21/tableswithrelations.png' %}" id="tableswithrelations" class="screenshot" alt="tableswithrelations">
    <button class="hide-btn" onclick="hideScreenshot('tableswithrelations')" style="display: none;" id="hide-tableswithrelations">Hide Screenshot</button>
</div>

<div class="step">
    <br>
    <br>
    <h2>Generate SQL</h2>
    <p>Now that all the required tables, columns and relationships are in place, the SQL code to actually create the objects can be generated.</p>
    <p>To do this clisk the Generate SQL button in the ERD tool.</p>
    <p>The screenshot shows the generated SQL.</p>
    <p></p>
    <p></p>
    <button class="screenshot-btn" onclick="toggleScreenshot('generatedsql', this)">View Screenshot</button>
    <img src="{% static 'portfolio/project21/generatedsql.png' %}" id="generatedsql" class="screenshot" alt="generatedsql">
    <button class="hide-btn" onclick="hideScreenshot('generatedsql')" style="display: none;" id="hide-generatedsql">Hide Screenshot</button>
</div>

<div class="step">
    <br>
    <br>
    <h2>Tables Created</h2>
    <p>This screenshot shows the created tables in the pgAdmin Object Explorer.</p
    <button class="screenshot-btn" onclick="toggleScreenshot('tablescreated2', this)">View Screenshot</button>
    <img src="{% static 'portfolio/project21/tablescreated2.png' %}" id="tablescreated2" class="screenshot" alt="tablescreated2">
    <button class="hide-btn" onclick="hideScreenshot('tablescreated2')" style="display: none;" id="hide-tablescreated2">Hide Screenshot</button>
</div>

<div class="step">
    <br>
    <br>
    <h2>Populate Data</h2>
    <p>Now that the database objects have been created successfully, the tables can be populated with data.</p>
    <p>This can happen in a number of ways.</p>
    <p>Data can be imported from a CSV file or scripts or from an application.</p>
    <p>Typically in real world environments the database will have been created to house data from multiple disparate sources including CSV files, applications, and other databases.</p>
    <p>Before going live with the new database the data from these sources will be prepared so it can be imported into the new database.</p>
</div>

{% endblock %}